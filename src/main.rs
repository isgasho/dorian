#[feature(proc_macro_hygiene, decl_macro)]
#[macro_use]
extern crate diesel;
use diesel::prelude::*;
use diesel::*;

// imports schema.rs that is generated by `diesel migration [run|redo]`
mod schema;

extern crate serde;
use serde::{Deserialize, Serialize};
use serde_json::*;

use std::error::Error;

mod db {
    extern crate serde;
    use serde::{Deserialize, Serialize};

    use super::schema::*;

    //
    // These Entity structs represent what actually exists in the database.
    //

    #[derive(Serialize, Deserialize, Identifiable, Queryable)]
    #[table_name = "users"]
    pub struct UserEntity {
        id: i32,
        name: String,
    }

    #[derive(Serialize, Deserialize, Identifiable, Queryable)]
    #[table_name = "entries"]
    pub struct EntryEntity {
        id: i32,
        tags: Vec<String>,
        uploader: String, // User.name
    }

    #[derive(Serialize, Deserialize, Identifiable, Queryable)]
    #[table_name = "tags"]
    pub struct TagEntity {
        id: i32,
        name: String,
    }

    #[derive(Serialize, Deserialize, Identifiable, Queryable)]
    #[table_name = "tagmap"]
    pub struct TagmapEntity {
        id: i32,
        tag_id: i32,
        entry_id: i32,
    }

    //
    // The structs below represent the structs that will be dealt with in rust code.
    //

    #[derive(Insertable)]
    pub struct User {
        name: String,
    }

    #[derive(Insertable)]
    #[table_name = "entries"] // diesel thought this was "entrys", funny
    pub struct Entry {
        uploader: String, // User.name
    }

    #[derive(Insertable)]
    pub struct Tag {
        name: String,
    }

    #[derive(Insertable)]
    #[table_name = "tagmap"]
    pub struct Tagmap {
        tag_id: i32,
        entry_id: i32,
    }
}

use std::result::Result;

// select all the tags
fn get_tags(conn: &SqliteConnection) -> Result<Vec<String>, Box<dyn Error>> {
    use schema::tags::dsl::*;

    let ts = tags.select(name).load::<String>(conn)?;

    Ok(ts)
}

// select all the entries
fn get_entries(conn: &SqliteConnection) -> Result<(Vec<i32>, Vec<String>), Box<dyn Error>> {
    use schema::entries::dsl::*;

    let (ids, us): (Vec<i32>, Vec<String>) = entries
        .select((id, uploader))
        .load::<(i32, String)>(conn)?
        .iter()
        .cloned()
        .unzip();

    Ok((ids, us))
}

// select all the tags that are associated with the given entry_id in the tagmap
fn get_entry_tags(conn: &SqliteConnection, eid: i32) -> Result<Vec<String>, Box<dyn Error>> {
    use schema::tagmap::dsl::*;
    use schema::tags::dsl::*;

    let tags_for_eid: Vec<String> = tags
        .select(name)
        .inner_join(tagmap)
        .filter(entry_id.eq(eid))
        .load::<String>(conn)?;

    Ok(tags_for_eid)
}

// add a new tag to the db
fn new_tag(conn: &SqliteConnection) /* -> Result<String, Box<dyn Error>> */ {}
fn new_entry(conn: &SqliteConnection) /* -> Result<String, Box<dyn Error>> */ {}

fn main() {
    use db::*;
    use schema::tags::dsl::*;

    let conn = SqliteConnection::establish("dorian.db").expect("error connecting to db");

    // select all tags for entry 1
    for tag in get_entry_tags(&conn, 1).expect("couldn't get tags").iter() {
        println!("got: {}", tag)
    }
}
